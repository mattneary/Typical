{"name":"Typical","tagline":"Strict typing for JavaScript.","body":"# Typical\r\nTypical provides strict typing to JavaScript functions. Here's a quick \r\nexample:\r\n\r\n```javascript\r\nfact = T(function(x) { return x == 0 ? 1 : x*fact(x-1) }, Number, Number)\r\n```\r\n\r\nThe argument and return types of the function `fact` will now be checked,\r\nand if not numeric, will throw an error. Here's what an error looks\r\nlike:\r\n\r\n```sh\r\nError: Expected argument at index 0 of anonymous to be of type Number.\r\n```\r\n\r\nAn additional benefit of typed functions is that they get partial application\r\nfor free. For example:\r\n\r\n```javascript\r\nsum = T(function(a, b) { return a + b }, Number, Number, Number)\r\nplus3 = sum(3)\r\n```\r\n\r\nSupported types include `Number`, `String`, `Boolean`, object types, sum \r\nand product types which we will discuss further later, list and \r\nkey-value types, and function types.\r\n\r\nThe primary motivation for Typical is to bring type-checking to the dynamic\r\nlanguage of JavaScript. Why? Type checking removes the possibility of an entire\r\nclass of bugs, and, additionally, provides the coder with a more clear view\r\nof the problem which his function solves. The type system of Typical is\r\nambitious, aiming to mirror Haskell in some regards, and is still a work in\r\nprogress.\r\n\r\n## Getting Started\r\n### Types\r\nTypes are provided as class constructors, like `Number`, `String`, or \r\n`MyClass` or as data types and algebraic types can either be formed by passing \r\nmultiple types to a data-type constructor, e.g., `T.Data(Number, String)`,\r\nor by making sum types of the form `a | b` with `T.Enum(a, b, ...)`. Recursive\r\ntypes can be defined using `T.Circular` and functions without return values\r\ncan be defined using `T.void`. Additional types can also be derived by wrapping\r\ntypes in lists of key-value pairs, e.g., `{name:String}` or `[Number]`.\r\nHere's how derived types can be used:\r\n\r\n```javascript\r\nfold = T(function(f, xs) {\r\n  return xs.reduce(f)\r\n}, T([Number, Number, Number]), [Number], Number)\r\n```\r\n\r\n### Algebraic Types\r\nTypical supports product and sum types, by means of `T.Data` and `T.Enum`,\r\nrespectively. A sum type is a sort of type union, allowing any of its\r\naddend types, which are constructed with `T.Data`, to be considered of its type. \r\nA product type joins the data held by multiple types into a single package. \r\nAdditionally, a data constructor can be defined inline with an enumerable type. \r\nFor example:\r\n\r\n```javascript\r\nNode = T.Enum(T.Data(\"Node\", Number, T.Circular), T.Data(\"Empty\", T.void))\r\nfunction lisp(x) {\r\n  if( x.length == 0 ) return T.Data(\"Empty\")(null)\r\n  return T.Data(\"Node\")(x[0], lisp(x.slice(1)))\r\n}\r\nT(lisp, [Number], Node)\r\n```\r\n\r\nNote the ability of the data type to be defined recursively upon the entire\r\ntype. This is a foundation for the creation of arbitrary data structures. A\r\ndata type is a contructor used to couple data. All sum types (made by `T.Enum`)\r\nmust consist exclusively of data types. Data types are built and used in one\r\nof the two ways which follow.\r\n\r\n```javascript\r\nPerson = T.Data(Number, String)\r\nPerson(1, \"Matt\")\r\n```\r\n\r\n```javascript\r\nT.Data(\"Person\", Number, String)\r\nT.Data(\"Person\")(1, \"Matt\")\r\n```\r\n\r\nWhen it comes time to extract data from these algebraic types, pattern matching\r\ncan be used.\r\n\r\n### Pattern Matching\r\nWhen aiming to make a polymorphic function which will extract the data from\r\na sum type, the `T.Match` function can be used. The following is an example of\r\nmethod delegation.\r\n\r\n```javascript\r\nnum = T.Match([NumOrStr, Number, Number],\r\n              [String, Number], function(x, y) { return parseInt(x)+y },\r\n              [Number, Number], function(x, y) { return x+y })\r\n```\t      \r\n\r\n\r\n### Function Types\r\nYou will, inevitably, wish to have a function accept another function as\r\nargument. In this case, you will need a means of defining a function's type.\r\nThe function `T` constructs a function type-class when passed an array. For example,\r\nthe following forms the type of a function from `Number` to `String`.\r\n\r\n```javascript\r\nStringify = T([Number, String])\r\n```\r\n\r\nThis type can then be used both as a constructor of typed functions and as\r\na type for function signatures. Here is an example of a function type at use:\r\n\r\n```javascript\r\nmap = T(function(f, xs) { return xs.map(f) }, T([Number, Number]), [Number], [Number])\r\nf = T(function(x) { return x+1 }, Number, Number)\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}